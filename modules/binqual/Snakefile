# Snakemake pipeline module to evaluate quality of your bins
# Should be able to deal with empty folders
# Fasta files must have .fa extension (checkm)
# binlist is a simple file containing `ls -d *.bins.fa`

# this snakemake module use checkpoint to autoupdate analysis based on binlist
# 1. Manage empty binlist
# 2. Update DAG based on bins:
#   a. checkm will process all bins in one single process
#   b. barnnap is one single rule because it's fast and I don't want to overcharge the diagram for nothing
#   c. trnascan-se is processing each bin independantly
# All informations are then concatenated into on single dataframe

import glob, os

SAMPLES = list(config)
TDATA = {}

checkpoint binqual_entry:
    input:
        "binning/{binner}/{sample}/{postbinning}/binlist.txt"
    output:
        "binning/{binner}/{sample}/{postbinning}/quality/binlist.txt"
    shell:
        'ln -s $(pwd)/{input} {output}'

# ------------------------------------------------------------------------
# Aggregation in case we don't have bins out of metabins 
# What we're doing here is giving to snakemake the binning checkfile output instead of the softwares
# outputs when no bins have been generated. I modified the software parser to deal with this input.

def read_binlist(fname):
    with open(fname) as f:
        return [line.strip() for line in f]

def agg_checkm(wildcard):
    # https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#data-dependent-conditional-execution
    binlist = checkpoints.binqual_entry.get(** wildcard).output[0]
    if os.stat(binlist) != 0 : return "binning/{binner}/{sample}/{postbinning}/quality/checkm/eval.tsv"
    return binlist

def agg_barrnap(wildcard):
    # https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#data-dependent-conditional-execution
    binlist = checkpoints.binqual_entry.get(** wildcard).output[0]
    if os.stat(binlist) != 0 : return "binning/{binner}/{sample}/{postbinning}/quality/barrnap/check.empty"
    return binlist

def agg_trnascan_arch(wildcard):
    # https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#data-dependent-conditional-execution
    binlist = checkpoints.binqual_entry.get(** wildcard).output[0]
    
    bins = read_binlist(binlist)
    data = {str(idx) : binpath for idx, binpath in enumerate(bins)}
    TDATA[(wildcard.binner, wildcard.sample, wildcard.postbinning)] = data
    
    respaths = [os.path.join('binning', wildcard.binner, wildcard.sample, wildcard.postbinning, 'quality/trnaScanSe/arch', 
                    'sample.' + str(idx) + '.trnascan.res.txt') for idx, binpath in data.items()]
    
    return respaths if respaths else binlist

def agg_trnascan_bact(wildcard):
    # https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#data-dependent-conditional-execution
    binlist = checkpoints.binqual_entry.get(** wildcard).output[0]
    #if os.stat(binlist) != 0 : return "binning/{binner}/{sample}/quality/trnaScanSe/check.bact.empty"
    #return binlist

    bins = read_binlist(binlist)
    data = {str(idx) : binpath for idx, binpath in enumerate(bins)}
    TDATA[(wildcard.binner, wildcard.sample, wildcard.postbinning)] = data

    respaths = [os.path.join('binning', wildcard.binner, wildcard.sample, wildcard.postbinning, 'quality/trnaScanSe/bact', 
                    'sample.' + str(idx) + '.trnascan.res.txt') for idx, binpath in data.items()]
    
    return respaths if respaths else binlist

# ------------------------------------------------------------------------------------
# Bins results analysis

rule prepare_checkm:
    input:
        "binning/{binner}/{sample}/{postbinning}/binlist.txt"
    output:
        touch("binning/{binner}/{sample}/{postbinning}/quality/checkm/inputs/check.empty")
    params:
        "binning/{binner}/{sample}/{postbinning}/quality/checkm/inputs/"
    shell:
        'while read fname; do ln -s $fname {params}/$(basename $fname).checkminput; done < $"{input}"'

rule checkm_lineage:
    input:
        "binning/{binner}/{sample}/{postbinning}/quality/checkm/inputs/check.empty"
    output:
        "binning/{binner}/{sample}/{postbinning}/quality/checkm/lineage.ms"
    params:
        bindir = "binning/{binner}/{sample}/{postbinning}/quality/checkm/inputs/",
        outdir = "binning/{binner}/{sample}/{postbinning}/quality/checkm"
    threads:
        16
    resources:
         mem_mb = 35000 #35G for pplacer
    priority: 
        1
    log:
        "logs/{binner}.{sample}.{postbinning}.quality.checkm.log"
    conda:
        "env/checkm.yaml"
    shell: 
        "checkm lineage_wf -t {threads} -x checkminput {params.bindir} {params.outdir} &> {log}"

rule checkm_quality:
    input :
        "binning/{binner}/{sample}/{postbinning}/quality/checkm/lineage.ms"
    output:
        "binning/{binner}/{sample}/{postbinning}/quality/checkm/eval.tsv"
    params:
        outdir = "binning/{binner}/{sample}/{postbinning}/quality/checkm"
    log:
        "logs/{binner}.{sample}.{postbinning}.quality.checkm.log"
    conda:
        "env/checkm.yaml"
    shell: 
        "checkm qa -o 2 {input} {params.outdir} > {output} 2>> {log}"

rule checkm_parse:
    input:
        agg_checkm
    output :
        "binning/{binner}/{sample}/{postbinning}/quality/checkm/results.tsv"
    script:
        "scripts/parse_checkm.py"

rule barrnap:
    input :
        "binning/{binner}/{sample}/{postbinning}/quality/binlist.txt"
    output:
        "binning/{binner}/{sample}/{postbinning}/quality/barrnap/check.empty"
    conda:
        "env/rna_tools.yaml"
    params:
        "binning/{binner}/{sample}/{postbinning}/quality/barrnap"
    log:
        "logs/{binner}.{sample}.{postbinning}.quality.barrnap.log"
    shell:
        'while read fname; do barrnap $fname > {params}/${{fname##*/}}.barrnap.txt; done < $"{input}"  && touch {output} 2> {log}'

rule barrnap_parse:
    input:
        agg_barrnap
    output :
        "binning/{binner}/{sample}/{postbinning}/quality/barrnap/results.tsv"
    script:
        "scripts/parse_barrnap.py"

rule trnaScanSe_arch:
    input:
        lambda wc: TDATA[(wc.binner, wc.sample, wc.postbinning)][wc.idx]
    output:
        'binning/{binner}/{sample}/{postbinning}/quality/trnaScanSe/arch/sample.{idx}.trnascan.res.txt'
    conda:
        "env/rna_tools.yaml"
    shell:
        'tRNAscan-SE -A -Q -o {output} {input}'

rule trnaScanSe_bact:
    input:
        lambda wc: TDATA[(wc.binner, wc.sample, wc.postbinning)][wc.idx]
    output:
        'binning/{binner}/{sample}/{postbinning}/quality/trnaScanSe/bact/sample.{idx}.trnascan.res.txt'
    conda:
        "env/rna_tools.yaml"
    shell:
        'tRNAscan-SE -B -Q -o {output} {input}'

rule trnaScanSe_parse:
    input:
        agg_trnascan_arch,
        agg_trnascan_bact
    output :
        "binning/{binner}/{sample}/{postbinning}/quality/trnaScanSe/results.tsv"
    params:
        lambda wc: TDATA[(wc.binner, wc.sample, wc.postbinning)]
    script:
        "scripts/parse_trnascan.py"

# ------------------------------------------------------------------------------------
# Final outputs

def fun(* args, ** kwargs):
    from itertools import product
    print (args, kwargs)
    for element in product(* args):
        print (element)
        yield element

rule fuse_info:
    input:
        checkm   = lambda wildcard: expand("binning/{binner}/{sample}/{postbinning}/quality/checkm/results.tsv", fun, binner=wildcard.binner, sample=SAMPLES, postbinning=wildcard.postbinning),
        barrnap  = lambda wildcard: expand("binning/{binner}/{sample}/{postbinning}/quality/barrnap/results.tsv", fun,binner=wildcard.binner, sample=SAMPLES, postbinning=wildcard.postbinning),
        trnascan = lambda wildcard: expand("binning/{binner}/{sample}/{postbinning}/quality/trnaScanSe/results.tsv", fun,binner=wildcard.binner, sample=SAMPLES, postbinning=wildcard.postbinning)
    output:
        bins = "binning/{binner}/quality_data/{postbinning}/tables/bins_info.tsv",
        mags = "binning/{binner}/quality_data/{postbinning}/tables/mags_info.tsv",
    params:
        magdir = "binning/{binner}/quality_data/{postbinning}/mags/"
    script:
        "scripts/fuse_bininfo.py"